# 바이브기획 방법론 - 발표 대본

**맥비기획 제11회 기획자/PM/PO 컨퍼런스**
**발표 시간: 30분**
**발표자: [이름]**

---

## 🎯 발표 목표

- 바이브기획 방법론 전체 흐름 소개 (Claude Code + Vibe)
- Claude Code와 appkit을 활용한 기획 자동화 소개
- 바이브를 통한 빠른 프로토타입 제작
- PM/PO가 실무에 바로 적용 가능한 워크플로우 제시
- md 기반 협업의 장점 전달

---

## 📋 타임라인

```
[0-2분]   HOOK - PM의 고통
[2-5분]   WHY - 왜 Claude Code인가?
[5-7분]   바이브(Vibe)란 무엇인가?
[7-17분]  WHAT - appkit으로 뭘 만드나?
[17-25분] HOW - 실제 협업 워크플로우
[25-30분] WRAP - md의 힘 + 시작하기
```

---

## [0-2분] HOOK - PM의 반복되는 고통

### 슬라이드 1: 타이틀

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   바이브기획 방법론
   AI 시대, PM/PO를 위한 새로운 기획 도구

   맥비기획 제11회 컨퍼런스
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**스크립트**:
> 안녕하세요. 오늘은 바이브기획 방법론에 대해 말씀드리겠습니다.
>
> PM, PO 여러분, 이런 경험 있으시죠?

---

### 슬라이드 2: 문제 제기

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   PM/PO의 3가지 현실적 고민
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

"기획은 속도가 생명인데..."

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 산출물 관리의 혼란
   - PRD_v1, v2, final, final_final...
   - 백로그 관리 안 됨 (어디까지 했더라?)
   - 개발 검수/이슈 체크 어려움
   - "이 기능 기획서 어디 있지?"

2️⃣ 프로젝트 히스토리 부재
   - 담당자 바뀌면 맥락 파악 2주
   - "왜 이렇게 기획했지?" 모름
   - 산출물 흩어져 있음 (Notion, Jira, Slack, 이메일...)
   - 과거 결정 추적 불가능

3️⃣ 기획 속도 느림
   - 바이브코딩: MVP 1주 완성
   - 기획: 문서만 2-3주 걸림
   - 개발은 빨라졌는데 기획이 병목
   - 속도 = 시장 경쟁력
```

**스크립트**:
> 기획은 속도가 생명입니다. 그런데 현실은 어떤가요?
>
> 첫째, 산출물 관리가 엉망입니다. PRD_final_final_최종_진짜최종.docx... 이런 파일 있으시죠? 백로그는 어디까지 했는지 모르겠고, 개발팀이 제대로 구현했는지 검수하기도 어렵습니다.
>
> 둘째, 프로젝트 히스토리가 없습니다. 담당자 바뀌면 2주는 맥락 파악하는 데 씁니다. "왜 이렇게 기획했지?" 물어볼 사람도 없고, 산출물은 Notion, Jira, Slack, 이메일에 흩어져 있습니다.
>
> 셋째, 기획 속도가 느립니다. 요즘 바이브코딩 쓰면 MVP를 1주 만에 만듭니다. 그런데 기획 문서 쓰는 데만 2-3주 걸립니다. 개발은 빨라졌는데 기획이 병목입니다.
>
> **속도가 시장 경쟁력인 시대**, 이 문제를 해결하는 **바이브기획 방법론**을 소개합니다.

---

## [2-5분] WHY - 왜 Claude Code인가?

### 슬라이드 3: ChatGPT vs Claude Code

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   ChatGPT (웹) vs Claude Code
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────┐
│  ChatGPT (웹 채팅)               │
├─────────────────────────────────┤
│ ❌ 대화만 가능                   │
│ ❌ 파일 복붙 필요                │
│ ❌ 새 채팅 = 맥락 리셋           │
│ ❌ 산출물 직접 정리              │
│ ❌ 협업 도구 연동 어려움         │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│  Claude Code (파일 기반)         │
├─────────────────────────────────┤
│ ✅ 프로젝트 폴더 전체 관리        │
│ ✅ 파일 자동 읽기/쓰기            │
│ ✅ CLAUDE.md로 맥락 영구 저장    │
│ ✅ 산출물 자동 생성 (md/sql)     │
│ ✅ Git, Notion, Jira 연동 쉬움   │
└─────────────────────────────────┘
```

**스크립트**:
> ChatGPT는 훌륭한 대화 도구입니다. 하지만 PM 업무 도구로는 한계가 있습니다.
>
> Claude Code는 **프로젝트 매니저 도구**입니다.
>
> 핵심 차이는 뭘까요? 바로 **파일 시스템**입니다.
>
> 모든 기획 산출물을 파일로 관리하면, AI가 맥락을 영구적으로 기억합니다.

---

### 슬라이드 4: 핵심 차이점

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   작업 방식 비교
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ChatGPT 방식:
┌─────────────────────────────────┐
│ 1. 아이디어 설명 → 채팅          │
│ 2. 결과 복사 → 워드 붙여넣기     │
│ 3. 수정 요청 → 다시 설명         │
│ 4. 다음 날 → 맥락 다시 설명      │
│                                 │
│ 🔴 맥락 리셋, 일회성 작업         │
└─────────────────────────────────┘

Claude Code 방식:
┌─────────────────────────────────┐
│ 1. 프로젝트 폴더 생성             │
│ 2. CLAUDE.md에 규칙 작성 (1회)  │
│ 3. /appkit.new [아이디어]        │
│    → 자동 산출                   │
│ 4. 다음 날 → 그대로 이어서 작업  │
│                                 │
│ 🟢 맥락 유지, 누적 작업           │
└─────────────────────────────────┘
```

**스크립트**:
> ChatGPT는 매번 새로 시작입니다.
>
> Claude Code는 프로젝트가 쌓입니다.
>
> 오늘 작업한 내용이 내일도 유지되고, 다음 주에도 유지됩니다.

---

### 슬라이드 5: CLAUDE.md = 프로젝트 위키

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   CLAUDE.md의 역할
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

회사 컨플루언스처럼:
┌─────────────────────────────────┐
│ # 프로젝트 개요                  │
│ 서비스 설명, 목표, 배경          │
│                                 │
│ # 타겟 유저                      │
│ 페르소나, 니즈, 페인 포인트      │
│                                 │
│ # 핵심 기능                      │
│ 우선순위, 범위, 제약사항         │
│                                 │
│ # 산출물 양식                    │
│ PRD 포맷, API 문서 스타일        │
└─────────────────────────────────┘

AI가 시작할 때마다 자동으로 읽음
→ 맥락 유지 자동화
→ 일관된 산출물
```

**스크립트**:
> CLAUDE.md는 프로젝트 위키입니다.
>
> 컨플루언스에 프로젝트 킥오프 문서 쓰듯이, 여기에 규칙을 적어두면 Claude가 시작할 때마다 자동으로 읽습니다.
>
> 이게 영구적인 맥락 유지의 비밀입니다.

---

### 슬라이드 6: 프로젝트 구조 예시

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   프로젝트 폴더 구조
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

tennis-booking-app/
├─ CLAUDE.md              ← 프로젝트 위키
├─ README.md              ← 프로젝트 개요
│
├─ rules/                 ← 작업 규칙
│  ├─ planning.md         ← 기획 규칙
│  └─ documentation.md    ← 문서화 규칙
│
├─ specs/                 ← 기능 명세
│  ├─ 001-user.md
│  ├─ 003-booking.md
│  └─ 005-promotion.md
│
├─ designs/               ← 설계 문서
│  ├─ api-endpoints.md
│  ├─ db-schema.sql
│  └─ architecture.md
│
└─ backlog/               ← 미래 아이디어
   └─ future-features.md

→ 모든 파일이 md (마크다운)
→ Git으로 버전 관리
→ Notion/Jira로 공유 가능
```

**스크립트**:
> 프로젝트 폴더는 이렇게 구성됩니다.
>
> 핵심은 모든 게 md 파일이라는 점입니다.
>
> 왜 md일까요? 잠시 후 설명드리겠습니다.

---

## [5-7분] 바이브(Vibe)란 무엇인가?

### 슬라이드 6.5: 바이브 소개

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   바이브(Vibe) = 자연어로 앱 만드는 AI
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

"테니스장 예약 앱 만들어줘"
         ↓
   실제 작동하는 앱 자동 생성

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

특징:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 자연어 입력
   "로그인 화면 만들어줘"
   "결제 기능 추가해줘"

2️⃣ 실시간 미리보기
   코드 생성 → 즉시 확인
   수정 요청 → 즉시 반영

3️⃣ 실제 배포 가능
   프로토타입 ❌
   실제 서비스 ✅

4️⃣ 개발 지식 불필요
   PM이 직접 만들 수 있음
```

**스크립트**:
> 바이브는 자연어로 앱을 만드는 AI 코딩 도구입니다.
>
> "테니스장 예약 앱 만들어줘"라고 말하면, 실제 작동하는 앱을 만들어줍니다.
>
> 프로토타입이 아니라, 실제 배포 가능한 앱입니다.
>
> 코딩 지식 없이도 PM이 직접 만들 수 있습니다.

---

### 슬라이드 6.6: 바이브기획 = Claude Code + Vibe

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   바이브기획 방법론 전체 흐름
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 기획 (Claude Code + appkit)
   ┌─────────────────────────┐
   │ /appkit.new             │
   │ /appkit.spec            │
   │ /appkit.design          │
   └───────────┬─────────────┘
               │
          산출물 (md)
               │
   ┌───────────┴─────────────┐
   │                         │
   ▼                         ▼
2️⃣ 디자인          3️⃣ 개발 (바이브)
┌─────────┐      ┌───────────────┐
│ UXPilot │      │ 바이브 코딩    │
│         │      │               │
│ 와이어  │      │ md → 실제 앱  │
│ 프레임  │      │               │
└─────────┘      └───────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

핵심: 기획서(md) → 바이브 → 앱
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

기존:
기획서 작성 → 개발자 전달 → 2주 대기
                         → 수정 요청
                         → 1주 대기

바이브기획:
기획서 작성 → 바이브 입력 → 30분 완성
                       → 즉시 수정 가능
```

**스크립트**:
> 바이브기획 방법론은 이렇게 작동합니다.
>
> 1단계: Claude Code로 기획서 자동 생성
> 2단계: 그 기획서를 바이브에 입력
> 3단계: 30분 만에 실제 앱 완성
>
> 기존에는 개발자 전달하고 2-3주 기다렸습니다.
>
> 이제는 PM이 직접 30분 만에 프로토타입을 만들 수 있습니다.
>
> 물론 실제 서비스는 개발자와 협업하지만, 빠른 검증이 가능해집니다.

---

### 슬라이드 6.7: 왜 "바이브기획"인가?

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   바이브기획의 3가지 핵심 가치
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 빠른 검증
   아이디어 → 기획서 → 프로토타입
   하루 만에 검증 가능

2️⃣ PM 자율성
   개발자 일정 기다릴 필요 없음
   직접 만들고 테스트

3️⃣ 협업 효율
   "이렇게 만들어주세요" ❌
   "이렇게 만들었어요" ✅
   구체적인 산출물로 소통

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

전통 기획:
아이디어 → 문서 → 개발자 → 대기

바이브기획:
아이디어 → 문서 → 직접 구현 → 검증
```

**스크립트**:
> 왜 "바이브기획"이라고 부를까요?
>
> 세 가지 이유가 있습니다.
>
> 첫째, 빠른 검증. 아이디어를 하루 만에 프로토타입으로 만들어 검증할 수 있습니다.
>
> 둘째, PM 자율성. 개발자 일정 기다릴 필요 없이 직접 만들 수 있습니다.
>
> 셋째, 협업 효율. "이렇게 만들어주세요"가 아니라 "이렇게 만들었어요"로 소통합니다.
>
> 구체적인 프로토타입을 보여주면 개발자와의 소통이 훨씬 명확해집니다.

---

## [7-17분] WHAT - appkit으로 뭘 만드나?

### 슬라이드 7: appkit 소개

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   appkit = AI 앱 기획 자동화 키트
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

문제:
"앱 아이디어 → 기획서" 과정이 반복됨

해결:
내 기획 방식을 6단계 사이클로 정리

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
6가지 커맨드:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

/appkit.new      → 아이디어 분해
                   (유사 서비스, 사용자 그룹, 핵심 기능)

/appkit.spec     → 기능 명세 작성
                   (사용자 여정, 비즈니스 규칙, 예외처리)

/appkit.merge    → 중복 통합
                   (기능 간 중복 제거, 통합)

/appkit.design   → DB/API 설계
                   (스키마, 엔드포인트, ERD)

/appkit.policy   → 비즈니스 규칙
                   (정책, 권한, 제약사항)

/appkit.verify   → 완성도 검증
                   (누락 체크, 일관성 검증)
```

**스크립트**:
> appkit은 제가 앱 기획할 때 반복하는 과정을 6단계로 정리한 겁니다.
>
> 이게 정답은 아닙니다. 제 방식일 뿐입니다.
>
> 여러분도 자신만의 kit을 만들 수 있습니다.
>
> 지금부터 appkit으로 뭘 할 수 있는지 보여드리겠습니다.

---

### 슬라이드 8: 자동 산출물 목록

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   appkit이 자동 생성하는 것들
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 정보설계 (IA)
├─ 사용자 그룹 분류
│  └─ 일반 사용자 / 관리자 / 시스템
├─ 핵심 기능 목록 (5-8개)
│  └─ 우선순위 + 의존성 맵
└─ 유사 서비스 벤치마킹
   └─ 3-5개 서비스 분석

📋 기능 명세 (Spec)
├─ 사용자 여정 (User Journey)
│  └─ Step-by-step 플로우
├─ 비즈니스 규칙 (Business Rules)
│  └─ 제약사항, 정책
├─ 예외 상황 (Edge Cases)
│  └─ 오류 처리, 대안
└─ 데이터 요구사항
   └─ 필수/선택 데이터

📋 시스템 설계 (Design)
├─ DB 스키마 (ERD)
│  └─ 테이블, 컬럼, 관계
├─ API 엔드포인트 목록
│  └─ Request/Response 명세
├─ 데이터 흐름도
│  └─ 컴포넌트 간 데이터 이동
└─ 상태 다이어그램
   └─ 상태 전이, 이벤트

📋 정책 문서 (Policy)
├─ 서비스 정책
│  └─ 환불, 취소, 변경
├─ 권한 관리 (RBAC)
│  └─ 역할별 권한
└─ 제약사항
   └─ 시스템 제약, 비즈니스 제약
```

**스크ripт**:
> 보통 PM이 2-3주 걸려서 만드는 산출물들입니다.
>
> appkit을 쓰면 이 모든 게 자동으로 나옵니다.
>
> 직접 보여드리겠습니다.

---

### 슬라이드 9-13: 라이브 데모 (5-7분)

**[화면 공유 시작]**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   실전 데모: 테니스장 예약 앱 기획
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**스크립트**:
> 테니스장 예약 앱을 기획한다고 가정하겠습니다.
>
> 쿠폰 할인 기능도 들어갑니다.

---

#### 데모 1: /appkit.new

**터미널 화면**:
```bash
$ claude

User: /appkit.new 테니스장 예약 앱, 쿠폰 할인 기능
```

**Claude 응답** (화면 캡처):
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 아이디어 분석 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 유사 서비스 벤치마킹 (3개)
────────────────────────────────────
1. 야놀자 (숙박 예약)
   - 실시간 재고 관리
   - 쿠폰/할인 시스템
   - 리뷰 시스템

2. 카카오맵 (장소 예약)
   - 지도 기반 검색
   - 예약 관리
   - 알림 시스템

3. 네이버 예약 (다목적 예약)
   - 통합 예약 플랫폼
   - 결제 시스템
   - 포인트/쿠폰

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 사용자 그룹 (3개)
────────────────────────────────────
1. 일반 사용자
   - 테니스장 검색
   - 예약/결제
   - 리뷰 작성

2. 장소 관리자
   - 테니스장 등록
   - 재고 관리
   - 예약 승인/거절
   - 정산

3. 플랫폼 운영자
   - 전체 모니터링
   - 쿠폰 발행
   - 통계 조회
   - 정책 관리

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 핵심 기능 (6개)
────────────────────────────────────
001-user      회원 관리
              (회원가입, 로그인, 프로필)

002-venue     장소 관리
              (등록, 검색, 상세)

003-booking   예약 관리
              (예약, 취소, 변경)

004-payment   결제 관리
              (결제, 환불, PG 연동)

005-promotion 프로모션 관리
              (쿠폰, 할인, 포인트)

006-review    리뷰 관리
              (작성, 조회, 신고)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 구현 순서 (의존성 기반)
────────────────────────────────────
Phase 1: 기본 인프라
  001-user → 002-venue

Phase 2: 핵심 비즈니스
  003-booking → 004-payment

Phase 3: 부가 기능
  005-promotion → 006-review

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ README.md 생성 완료
✅ features/ 폴더 생성 완료
✅ 다음 단계: /appkit.spec [기능번호] [설명]
```

**스크립트**:
> 한 줄 입력했더니 이렇게 나왔습니다.
>
> 유사 서비스 3개 분석하고, 사용자 그룹 나누고, 핵심 기능 6개로 정리했습니다.
>
> 구현 순서까지 의존성 기반으로 제안했습니다.
>
> 보통 이 작업에 2-3시간 걸리는데, 30초 만에 완료됐습니다.

---

#### 데모 2: /appkit.spec

**터미널 화면**:
```bash
User: /appkit.spec 003-booking "메인에서 검색해서 예약하기"
```

**Claude 응답**:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 기능 명세 작성 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📄 specs/003-booking-search-and-book.md

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
## 사용자 여정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 홈 화면 진입
   - [지역] [날짜] [시간] 입력 폼 노출

2. 검색 조건 입력
   - 지역: 드롭다운 (서울/경기/...)
   - 날짜: 캘린더 (오늘+1일 ~ +30일)
   - 시간: 시간대 선택 (06:00~22:00)

3. 검색 버튼 클릭
   - 로딩 인디케이터 표시
   - API 호출: GET /api/venues/search

4. 검색 결과 목록 확인
   - 거리순 정렬 (기본)
   - 카드 형태 (사진, 이름, 거리, 가격, 평점)
   - 무한 스크롤 (20개씩)

5. 원하는 테니스장 선택
   - 상세 페이지 이동
   - 시간대별 재고 확인

6. 시간대 선택
   - 예약 가능 시간대만 활성화
   - 선택 시 가격 표시

7. 예약 확인
   - 요약 정보 확인 (장소, 날짜, 시간, 가격)
   - 쿠폰 적용 (선택)

8. 결제 페이지 이동
   - payment 기능으로 연결

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
## 비즈니스 규칙
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 예약 시간 제약
- 예약 가능 시간: 현재 시각 + 1시간 이후
- 최대 예약 기간: 오늘 기준 +30일
- 예약 단위: 1시간 (일부 장소는 30분)

### 중복 예약 방지
- 같은 사용자: 동일 시간대 1건만 예약 가능
- 같은 장소: 시간대별 재고 체크 (sold out 처리)

### 취소 정책
- 24시간 전: 무료 취소 (100% 환불)
- 12시간 전: 50% 환불
- 12시간 이내: 환불 불가

### 쿠폰 적용
- 1회 예약당 1개 쿠폰만 사용
- 할인율/정액 할인 선택
- 최소 결제 금액 조건 체크

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
## 예외 상황 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 검색 결과 0건
- "조건을 변경해보세요" 메시지
- 추천 지역/시간대 제안
- 인기 테니스장 추천

### 재고 마감 (Sold Out)
- 실시간 재고 체크 (최종 결제 전)
- 마감 시: "대기 예약" 제안
- 취소 발생 시 자동 알림

### 결제 실패
- 예약 상태: 10분간 홀드 (pending)
- 10분 후 자동 취소
- 재시도 옵션 제공

### 동시 예약 충돌
- Optimistic Locking 적용
- 먼저 결제 완료한 사용자 우선
- 후순위: "이미 예약된 시간대" 안내

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
## 데이터 요구사항
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 필수 데이터
- user_id (로그인 필수)
- venue_id (장소 선택)
- date_time (날짜 + 시간)
- duration (시간 단위)

### 선택 데이터
- coupon_id (쿠폰 사용 시)
- memo (요청사항)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
## 의존성
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

### 선행 필요
- 001-user (로그인 필요)
- 002-venue (장소 데이터 필요)

### 후행 연결
- 004-payment (결제 진행)
- 005-promotion (쿠폰 적용)
- 006-review (예약 후 리뷰 작성)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ specs/003-booking-search-and-book.md 저장 완료
```

**스크립트**:
> 기능 하나를 구체화했습니다.
>
> 사용자 여정 8단계, 비즈니스 규칙 4가지, 예외 상황 4가지, 의존성까지 자동으로 작성됐습니다.
>
> PM이 고민하는 엣지 케이스까지 제안해줍니다.
>
> 이 문서 그대로 개발자에게 전달 가능합니다.

---

#### 데모 3: /appkit.design

**터미널 화면**:
```bash
User: /appkit.design
```

**Claude 응답**:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 시스템 설계 완료
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📄 designs/api-endpoints.md
📄 designs/db-schema.sql
📄 designs/architecture.md

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
API 엔드포인트 (일부)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 예약 생성
POST /api/bookings

Request:
{
  "venueId": "uuid",
  "userId": "uuid",
  "dateTime": "2025-11-20T14:00:00Z",
  "duration": 60,
  "couponId": "uuid?" (optional)
}

Response 200:
{
  "bookingId": "uuid",
  "status": "pending",
  "totalAmount": 50000,
  "discountAmount": 5000,
  "finalAmount": 45000,
  "expiresAt": "2025-11-20T14:10:00Z"
}

Response 409 (Conflict):
{
  "error": "ALREADY_BOOKED",
  "message": "이미 예약된 시간대입니다"
}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
DB 스키마 (일부)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

-- 예약 테이블
CREATE TABLE bookings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  venue_id UUID NOT NULL REFERENCES venues(id),

  date_time TIMESTAMP NOT NULL,
  duration INT NOT NULL, -- 분 단위

  status VARCHAR(20) NOT NULL,
    -- 'pending', 'confirmed', 'cancelled', 'completed'

  total_amount INT NOT NULL,
  discount_amount INT DEFAULT 0,
  final_amount INT NOT NULL,

  coupon_id UUID REFERENCES coupons(id),

  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  CONSTRAINT unique_venue_datetime
    UNIQUE(venue_id, date_time)
);

-- 인덱스
CREATE INDEX idx_bookings_user
  ON bookings(user_id);

CREATE INDEX idx_bookings_venue_date
  ON bookings(venue_id, date_time);

CREATE INDEX idx_bookings_status
  ON bookings(status)
  WHERE status IN ('pending', 'confirmed');

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ 파일 저장 완료
```

**스크립트**:
> API 명세서와 DB 스키마까지 나왔습니다.
>
> Request/Response 포맷, 에러 코드, 테이블 스키마, 인덱스까지 자동 생성됐습니다.
>
> 저는 SQL 잘 몰라도 됩니다. appkit이 자동으로 만들어줬으니까요.
>
> 이 파일들을 개발자에게 전달하면 바로 개발 시작 가능합니다.

**[화면 공유 종료]**

---

### 슬라이드 14: 데모 정리

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   데모 요약: 3개 커맨드로 완성
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

/appkit.new
→ 아이디어 분해 (30초)
→ 유사 서비스, 사용자 그룹, 핵심 기능

/appkit.spec
→ 기능 명세 작성 (1분)
→ 사용자 여정, 비즈니스 규칙, 예외처리

/appkit.design
→ 시스템 설계 (2분)
→ API, DB, 아키텍처

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

총 소요 시간: 약 5분
기존 방식: 2-3주

→ 96% 시간 절감
```

**스크립트**:
> 3개 커맨드로 5분 만에 완성했습니다.
>
> 기존 방식으로 2-3주 걸리던 작업입니다.
>
> 물론 100% 완벽하진 않습니다. 수정은 필요합니다.
>
> 하지만 80% 초안을 5분 만에 만들고, 20%만 다듬으면 됩니다.

---

## [17-25분] HOW - 실제 협업 워크플로우

### 슬라이드 15: 전체 워크플로우

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   바이브기획 → 협업 → 개발/디자인
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 기획 (Claude Code + appkit)
   ┌───────────────────────────┐
   │ /appkit.new               │
   │ /appkit.spec              │
   │ /appkit.design            │
   └───────────┬───────────────┘
               │
         산출물 (md, sql)
         - 사용자 여정
         - 비즈니스 규칙
         - API/DB 설계
               │
   ┌───────────┴───────────────┐
   │                           │
   ▼                           ▼
2️⃣ UI/UX (AI 자동)   3️⃣ 개발
┌──────────────┐     ┌─────────┐
│  UXPilot     │     │바이브   │
│              │     │코딩     │
│✅ 와이어프레임│  OR │        │
│✅ 정보 우선순위     │개발자   │
│✅ 인터랙션    │     └────┬────┘
│✅ 시각 위계   │          │
└───────┬──────┘          │
        │                 │
        ▼                 ▼
   디자이너          백엔드/프론트
   (디테일만)        (구현)

4️⃣ 협업 도구 연동
┌──────────────────────────────┐
│ Jira    Notion    Slack      │
│ (이슈)  (문서화)  (알림)      │
└──────────────────────────────┘

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

핵심: AI가 기획+UX+UI 초안 작성
     → 사람은 검토/디테일만
```

**스크립트**:
> 전체 워크플로우는 이렇습니다.
>
> 1단계: PM이 appkit으로 기획 산출물 생성
>
> 2단계: **UXPilot이 와이어프레임뿐만 아니라**, 정보 우선순위, 인터랙션 패턴, 시각적 위계까지 자동으로 만들어줍니다.
>
> 이게 핵심입니다. **전통적으로 기획자, UX, UI 디자이너가 나눠서 하던 일을 AI가 한 번에 처리**합니다.
>
> 디자이너는 브랜드 컬러 적용하고 디테일만 다듬으면 됩니다.
>
> 3단계: 바이브로 자동 개발하거나, 개발자에게 명세서 전달
>
> 4단계: Jira/Notion으로 프로젝트 관리
>
> 핵심은 모든 단계에서 md 파일을 쓴다는 점입니다.

---

### 슬라이드 16: UXPilot 연동 - AI가 3가지 역할 모두 수행

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   UXPilot이 하는 3가지 역할
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

전통 UI 설계 프로세스:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 기획자
   - 정보 우선순위 정의
   - 와이어프레임 스케치
   - 플로우 설계

2️⃣ UX 디자이너
   - 사용성 검토
   - 인터랙션 패턴 설계
   - 정보 구조(IA) 최적화

3️⃣ UI 디자이너
   - 시각적 위계 설정
   - 컬러/타이포 적용
   - 디자인 시스템 반영

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

바이브기획에서는:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ AI가 3가지 역할 모두 수행

1️⃣ appkit이 기획 (정보 설계)
   → 사용자 여정, 비즈니스 규칙

2️⃣ UXPilot이 UX 설계
   → 와이어프레임, 인터랙션 패턴

3️⃣ UXPilot이 UI 제안
   → 시각적 위계, 레이아웃 구조
```

**스크립트**:
> 전통적으로 UI 설계는 3가지 역할이 필요했습니다.
>
> 기획자가 정보 우선순위를 정하고, UX 디자이너가 사용성을 검토하고, UI 디자이너가 시각화합니다.
>
> 하지만 바이브기획에서는 **AI가 이 3가지를 모두 처리**합니다.
>
> appkit이 기획을, UXPilot이 UX와 UI 설계를 담당합니다.

---

### 슬라이드 16-1: UXPilot 실제 워크플로우

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   UXPilot 연동 워크플로우
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Step 1: spec 파일 확인
┌─────────────────────────────────┐
│ specs/003-booking.md             │
│                                 │
│ ## 사용자 여정                   │
│ 1. 홈 화면 진입                  │
│    - [지역][날짜][시간] 입력 폼  │
│ 2. 검색 조건 입력                │
│ 3. 검색 버튼 클릭                │
│ 4. 결과 목록 확인                │
│    - 거리순 정렬 (기본)          │
│    - 카드 형태 노출              │
└─────────────────────────────────┘

Step 2: UXPilot에 붙여넣기
"이 사용자 여정으로 와이어프레임 만들어줘"

Step 3: AI가 자동 생성하는 것들
┌─────────────────────────────────┐
│ ✅ 와이어프레임                  │
│    [홈 화면]                     │
│    ┌─────────────────┐           │
│    │ 지역: [드롭다운]│           │
│    │ 날짜: [캘린더]  │           │
│    │ 시간: [시간선택]│           │
│    │ [검색하기]      │           │
│    └─────────────────┘           │
│                                 │
│ ✅ 정보 우선순위 제안             │
│    "검색 조건이 가장 중요"       │
│    "상단 고정 배치 권장"         │
│                                 │
│ ✅ 인터랙션 패턴                 │
│    "드롭다운: 지역 계층 구조"    │
│    "캘린더: 오늘+1 ~ +30일"      │
│    "버튼: 로딩 인디케이터"       │
│                                 │
│ ✅ 시각적 위계 제안               │
│    "검색 버튼: Primary 강조"     │
│    "결과 카드: 사진 > 이름 > 가격"│
└─────────────────────────────────┘

Step 4: 디자이너 작업 간소화
→ 디테일 디자인만 집중
→ 컬러/타이포만 적용
```

**스크립트**:
> spec 파일을 UXPilot에 넣으면 이렇게 나옵니다.
>
> 단순히 와이어프레임만 나오는 게 아닙니다.
>
> **정보 우선순위 제안** - "검색 조건이 가장 중요하니 상단에 고정하세요"
>
> **인터랙션 패턴** - "드롭다운은 지역 계층 구조로, 캘린더는 +30일까지만"
>
> **시각적 위계** - "검색 버튼은 Primary로 강조, 결과 카드는 사진 먼저"
>
> 전통적으로 **기획자, UX, UI 디자이너가 2-3일 걸려 정리하던 내용**이 자동으로 나옵니다.
>
> 디자이너는 이제 브랜드 컬러 적용하고 디테일만 다듬으면 됩니다.

---

### 슬라이드 17: 바이브코딩/개발자 전달

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   개발자 전달 워크플로우
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Option 1: 바이브코딩 (자동 개발)
┌─────────────────────────────────┐
│ designs/api-endpoints.md        │
│ designs/db-schema.sql           │
│          ↓                      │
│    바이브 (AI 코딩)              │
│          ↓                      │
│   실제 코드 자동 생성             │
└─────────────────────────────────┘

Option 2: 개발자에게 전달
┌─────────────────────────────────┐
│ 전달 파일:                       │
│ - specs/*.md   (기능 명세)       │
│ - designs/api-endpoints.md      │
│ - designs/db-schema.sql         │
│                                 │
│ 개발자:                          │
│ "명세 보고 개발 시작"             │
│                                 │
│ 장점:                            │
│ - 문서 완성도 높음               │
│ - 엣지 케이스 이미 정리됨        │
│ - API 포맷 명확                  │
└─────────────────────────────────┘
```

**스크립트**:
> 개발은 두 가지 방법이 있습니다.
>
> 바이브코딩으로 자동 개발하거나, 개발자에게 명세서 전달하거나.
>
> 어느 쪽이든 md 파일 기반이라 전달이 쉽습니다.

---

### 슬라이드 18: Jira 연동

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Jira 이슈 생성
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

spec 파일 → Jira 이슈

┌─────────────────────────────────┐
│ 📋 JIRA 이슈                     │
├─────────────────────────────────┤
│ 제목: [기능] 검색 예약 플로우    │
│                                 │
│ 설명:                            │
│ (사용자 여정 복사)               │
│                                 │
│ 인수 조건:                       │
│ (비즈니스 규칙 복사)             │
│                                 │
│ 하위 작업:                       │
│ - [ ] API 구현                  │
│ - [ ] DB 마이그레이션            │
│ - [ ] 예외처리                   │
│ - [ ] 테스트                     │
│                                 │
│ 관련 문서:                       │
│ - specs/003-booking.md          │
│ - designs/api-endpoints.md      │
└─────────────────────────────────┘

→ md에서 복사만 하면 됨
→ 일관된 이슈 포맷
```

**스크립트**:
> Jira 이슈 만들 때도 md 파일에서 복사만 하면 됩니다.
>
> 사용자 여정은 설명에, 비즈니스 규칙은 인수 조건에, 의존성은 관련 이슈에.
>
> 일관된 포맷으로 이슈가 생성됩니다.

---

### 슬라이드 19: Notion 프로젝트 관리

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Notion 문서화
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

프로젝트 폴더 → Notion 페이지

📁 테니스장 예약 앱 (Notion 페이지)
├─ 📄 Overview
│  └─ README.md 내용 복사
│
├─ 📁 Features
│  ├─ 001 회원 관리
│  ├─ 003 예약 관리
│  └─ 005 프로모션
│     └─ specs/*.md 내용 복사
│
├─ 📁 System Design
│  ├─ API 명세
│  ├─ DB 스키마
│  └─ 아키텍처
│     └─ designs/*.md 내용 복사
│
└─ 📁 Backlog
   └─ future-features.md 내용 복사

→ 팀 전체가 Notion에서 확인
→ 실시간 업데이트 가능
```

**스크립트**:
> Notion으로 문서화할 때도 md 파일을 복사하면 됩니다.
>
> 팀 전체가 Notion에서 프로젝트 현황을 확인할 수 있습니다.

---

### 슬라이드 20: Slack 자동화 (보너스)

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   Slack 알림 자동화
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

appkit 완료 시 자동 알림:

┌─────────────────────────────────┐
│ #프로젝트-알림                   │
├─────────────────────────────────┤
│ 🤖 Appkit Bot                    │
│                                 │
│ ✅ 기능 명세 작성 완료            │
│                                 │
│ 📄 003-booking-search-and-book  │
│                                 │
│ 주요 내용:                       │
│ - 사용자 여정 8단계              │
│ - 비즈니스 규칙 4개              │
│ - 예외 상황 4개                  │
│                                 │
│ [파일 보기] [Jira 생성] [검토]   │
└─────────────────────────────────┘

→ 팀원 실시간 확인
→ 빠른 피드백
```

**스크립트**:
> Slack 연동도 가능합니다.
>
> appkit 작업 완료될 때마다 자동으로 알림이 가고, 팀원이 바로 확인할 수 있습니다.

---

## [25-30분] WRAP - md의 힘 + 시작하기

### 슬라이드 21: 왜 md인가?

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   모든 것을 md로 작성하는 이유
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ AI가 가장 잘 이해하는 형식
   ✅ 구조화 쉬움 (헤더, 리스트, 표)
   ✅ 토큰 효율 좋음 (비용 절감)
   ✅ 컨텍스트 파악 정확

2️⃣ 모든 도구와 호환
   ✅ GitHub (버전 관리)
   ✅ Notion (문서화)
   ✅ Jira (이슈 관리)
   ✅ Slack (메시지)
   ✅ 복붙만 하면 됨

3️⃣ 버전 관리 가능
   ✅ Git으로 변경 이력 추적
   ✅ 브랜치로 여러 버전 관리
   ✅ 협업 시 충돌 해결
   ✅ 롤백 쉬움

4️⃣ 초지능 비서처럼 동작
   ✅ 파일 = AI의 장기 기억
   ✅ 프로젝트 전체 맥락 보유
   ✅ "3달 전 기획" 즉시 찾음
   ✅ 맥락 기반 자동 작업
```

**스크립트**:
> 왜 모든 걸 md로 작성할까요?
>
> 4가지 이유가 있습니다.
>
> AI 이해, 도구 호환, 버전 관리, 그리고... 초지능 비서.

---

### 슬라이드 22: 초지능 비서의 비밀

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   md 파일 = AI의 장기 기억
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

프로젝트 폴더 구조:
┌─────────────────────────────────┐
│ tennis-booking-app/              │
├─────────────────────────────────┤
│ CLAUDE.md         프로젝트 위키  │
│ rules/            작업 규칙      │
│ specs/            기능 명세 (50개)│
│ designs/          설계 문서      │
│ backlog/          미래 아이디어  │
└─────────────────────────────────┘
         ▼
   Claude가 모두 읽음
         ▼
   초지능 비서 모드 활성화

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

사용 예시:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

User: "003-booking의 취소 정책 뭐였지?"

Claude:
→ specs/ 폴더 검색
→ 003-booking.md 찾기
→ 비즈니스 규칙 섹션 읽기
→ 취소 정책 찾아서 답변

"24시간 전 무료 취소,
 12시간 전 50% 환불,
 12시간 이내 환불 불가입니다."

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

User: "취소 정책을 48시간 전으로 바꿔줘"

Claude:
→ specs/003-booking.md 열기
→ 비즈니스 규칙 섹션 수정
→ 24시간 → 48시간 변경
→ 저장

"수정 완료했습니다."

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

이게 ChatGPT와의 결정적 차이
```

**스크립트**:
> md 파일로 모든 걸 관리하면 Claude가 초지능 비서처럼 동작합니다.
>
> "3달 전에 기획한 취소 정책 뭐였지?" → 즉시 찾아줌
>
> "그거 48시간으로 바꿔줘" → 파일 찾아서 수정
>
> 파일만 남아있으면 Claude가 모든 걸 기억합니다.
>
> 이게 ChatGPT와의 결정적 차이입니다.

---

### 슬라이드 23: 시작하기 3단계

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   오늘부터 바로 시작하기
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1단계: Claude Code 설치 (10분)
┌─────────────────────────────────┐
│ 1. VS Code 설치                  │
│    https://code.visualstudio.com│
│                                 │
│ 2. Claude Code 설치              │
│    https://claude.ai/code       │
│                                 │
│ 3. 프로젝트 폴더 생성             │
│    내 문서/my-first-project     │
└─────────────────────────────────┘

2단계: 첫 프로젝트 만들기 (30분)
┌─────────────────────────────────┐
│ 1. CLAUDE.md 작성                │
│    프로젝트 개요 3줄             │
│                                 │
│ 2. appkit 설치 (GitHub)          │
│    .claude/commands/ 복사       │
│                                 │
│ 3. 간단한 아이디어로 실행         │
│    /appkit.new [아이디어]       │
│                                 │
│ 4. 산출물 확인                   │
│    specs/, designs/ 폴더         │
└─────────────────────────────────┘

3단계: 팀에 공유 (1주)
┌─────────────────────────────────┐
│ 1. Notion에 md 파일 업로드       │
│    팀원들이 확인                 │
│                                 │
│ 2. 디자이너/개발자에게 전달       │
│    피드백 받기                   │
│                                 │
│ 3. 피드백으로 개선               │
│    CLAUDE.md, rules/ 수정       │
│                                 │
│ 4. 점진적으로 확장               │
│    다른 프로젝트에도 적용        │
└─────────────────────────────────┘
```

**스크립트**:
> 시작은 간단합니다. 3단계만 따라하세요.
>
> 10분 설치, 30분 실험, 1주 확장.
>
> 완벽하게 준비하려고 하지 마세요. 일단 해보세요.

---

### 슬라이드 24: 실전 팁

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   성공을 위한 3가지 팁
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 완벽주의 버리기
   ❌ "완벽한 CLAUDE.md 작성"
      → 시작 못 함

   ✅ 3줄로 시작 → 점진적 개선
      → 써보면서 추가

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

2️⃣ 작게 시작하기
   ❌ "회사 전체 프로세스 바로 적용"
      → 복잡해서 실패

   ✅ 내 반복 작업 1개만
      → 성공 경험 쌓기

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

3️⃣ appkit은 참고용
   ❌ "appkit 그대로 써야 함"
      → 내 방식 무시

   ✅ 내 방식대로 커스터마이징
      → 내 kit 만들기

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

핵심: "내 방식을 md로 정리"
```

**스크립트**:
> 3가지만 기억하세요.
>
> 완벽주의 버리고, 작게 시작하고, 내 방식으로 만들기.
>
> appkit은 참고용입니다. 여러분만의 kit을 만드세요.

---

### 슬라이드 25: 마무리

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   바이브기획 방법론 정리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ Claude Code = 파일 기반 PM 도구
   → ChatGPT의 한계 극복

✅ appkit = 기획 자동화 키트
   → 96% 시간 절감

✅ 산출물 = IA, Spec, API, DB
   → 개발자 전달 가능 수준

✅ 협업 = UXPilot, 바이브, Jira, Notion
   → md 기반 완벽 호환

✅ md = 초지능 비서의 비밀
   → AI의 장기 기억

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

지금 시작하세요:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. VS Code + Claude Code 설치
2. 프로젝트 하나로 실험
3. 팀에 공유

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

감사합니다! 🙏
```

**스크립트**:
> 바이브기획 방법론, 정리하겠습니다.
>
> Claude Code로 파일 기반 작업하고, appkit으로 자동화하고, md로 협업합니다.
>
> 이 세 가지만 기억하세요.
>
> 오늘 당장 시작하세요. VS Code 설치하고, 프로젝트 하나 만들어보세요.
>
> 발표 마치겠습니다. 감사합니다.

---

## Q&A 예상 질문

### Q1: Claude 비용은 얼마나 드나요?

**A**:
> Claude Pro 요금제가 월 $20입니다.
>
> 무제한 사용 가능하고, 기획서 외주 1건 비용보다 저렴합니다.
>
> 팀 전체가 아니라 PM만 쓰면 되기 때문에, 팀당 $20이면 충분합니다.

---

### Q2: 개발 지식이 없어도 가능한가요?

**A**:
> 네, 가능합니다.
>
> 마크다운 문법만 알면 됩니다. 헤더(#), 리스트(-), 표 정도만 쓸 줄 알면 충분합니다.
>
> SQL, API 설계 같은 건 appkit이 자동으로 만들어줍니다.
>
> PM은 "뭘 만들지"만 정의하면 됩니다. "어떻게 만들지"는 appkit이 알아서 합니다.

---

### Q3: 기존 Notion/Confluence와 차이는 무엇인가요?

**A**:
> Notion은 문서 저장소입니다. 사람이 읽기 위한 도구죠.
>
> Claude Code는 AI 작업 환경입니다. AI가 읽고 작업하기 위한 도구입니다.
>
> Notion에 정리만 하면 AI가 못 읽습니다. md 파일로 관리하면 AI가 읽고 자동 작업이 가능합니다.
>
> 물론 md 파일을 Notion에 복사해서 팀원들과 공유할 수 있습니다. 둘 다 쓰면 됩니다.

---

### Q4: 팀원들 학습 곡선은 어떤가요?

**A**:
> PM만 Claude Code를 쓰면 됩니다.
>
> 산출물(md 파일)은 Notion이나 Jira에 공유하면, 팀원들은 기존 방식대로 확인합니다.
>
> 디자이너는 spec 파일만 받아서 디자인하고, 개발자는 API 명세만 받아서 개발합니다.
>
> 팀 전체가 새로운 도구를 배울 필요 없습니다.

---

### Q5: 보안은 괜찮나요?

**A**:
> Claude Code는 로컬에서 실행됩니다.
>
> 파일은 내 컴퓨터에만 저장되고, Claude API로 전송할 때만 암호화 통신됩니다.
>
> 민감한 정보는 CLAUDE.md에 적지 않으면 됩니다.
>
> 추가로, Git Private Repository로 관리하면 팀 내부에서만 공유 가능합니다.

---

### Q6: appkit을 꼭 써야 하나요?

**A**:
> 아니요, appkit은 예시입니다.
>
> 여러분만의 방식을 만들 수 있습니다.
>
> 예를 들어, 마케팅 PM이라면 "marketing-kit"을 만들 수 있고, 커머스 PM이라면 "commerce-kit"을 만들 수 있습니다.
>
> appkit은 참고용입니다. 구조를 보고 영감을 받아서 내 kit을 만드세요.

---

### Q7: 프로젝트가 커지면 관리가 어렵지 않나요?

**A**:
> md 파일이 많아지면 오히려 관리가 쉬워집니다.
>
> Git으로 버전 관리하면 변경 이력이 모두 남고, 검색도 쉽습니다.
>
> Claude에게 "003-booking 관련 파일 다 찾아줘"라고 하면 자동으로 찾아줍니다.
>
> 또한, 폴더 구조를 잘 만들면 (specs/, designs/, backlog/) 파일이 많아도 정리됩니다.

---

### Q8: 기존 프로젝트에도 적용 가능한가요?

**A**:
> 네, 가능합니다.
>
> 기존 PRD, API 문서를 md로 변환해서 프로젝트 폴더에 넣으면 됩니다.
>
> CLAUDE.md에 프로젝트 컨텍스트를 적고, 기존 문서들을 정리하면 Claude가 바로 이해합니다.
>
> 점진적으로 적용하세요. 새 기능부터 appkit으로 기획하고, 기존 기능은 천천히 정리하면 됩니다.

---

## 📎 발표 준비 체크리스트

### 필수 준비물
- [ ] 슬라이드 (25장)
- [ ] 데모 영상 (미리 녹화, 5분)
- [ ] 노트북 + HDMI 케이블
- [ ] 예비 USB (슬라이드 백업)

### 데모 준비
- [ ] appkit 설치 확인
- [ ] 데모 프로젝트 준비 (tennis-booking-app)
- [ ] /appkit.new 실행 결과 미리 확인
- [ ] /appkit.spec 실행 결과 미리 확인
- [ ] /appkit.design 실행 결과 미리 확인

### 시간 관리
- [ ] 각 섹션별 타이머 설정
- [ ] 25분 지점 알람 (Q&A 5분 남음)
- [ ] 예비 슬라이드 준비 (시간 부족 시 스킵)

### 발표 연습
- [ ] 전체 리허설 1회 (30분 타이머)
- [ ] 데모 부분 집중 연습
- [ ] Q&A 답변 숙지

---

## 🎬 발표 팁

### 시간 배분
- HOOK (2분): 빠르게
- WHY (5분): 명확하게
- WHAT (10분): 데모 중심 (라이브 말고 녹화)
- HOW (8분): 실용성 강조
- WRAP (5분): 간결하게

### 강조할 포인트
1. **파일 기반** - ChatGPT와의 차이
2. **96% 시간 절감** - 구체적 수치
3. **md의 힘** - 초지능 비서
4. **바로 시작 가능** - 진입장벽 낮음

### 피해야 할 것
- 기술 용어 남발 (SQL, API 등은 최소화)
- 완벽 강조 (80% 초안 강조)
- appkit 집착 (참고용 강조)

---

발표 화이팅! 🚀
